!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Global helper functions
!
! !INTERFACE:
!  Included in ModuleMem.F90
!
! !DESCRIPTION:
!  This file contains the helper routines for the assignment
!  and retrieval of rates from the main source/sink term arrays
!  This is a special file included when the D1SOURCE key is activated.
!  It also activates the key ONESOURCE
!
! !REVISION HISTORY:
!  Author(s): Marcello Vichi
!
!EOP
!-----------------------------------------------------------------------
!BOC

!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
! flux functions
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          subroutine flux_vector(iiSub,origin,destination,flux)
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            use constants, only: RLEN, ZERO,  SEC_PER_DAY
            use global_mem, only: LOGUNIT

            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            real(RLEN),intent(IN) :: flux(:)
            character(len=8)                   :: D23
            integer :: j
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            !BEGIN compute
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#ifdef IFORT
            TESTNANVECTOR(flux,iiSub,origin,destination)
            CHECKFLUX(-1,iiSub,origin,destination)
#endif
            if ( origin /= destination ) then
              select case ( iiSub )
                case (iiPel)
                  D3SOURCE(origin,:) = D3SOURCE(origin,:) - &
                      flux/SEC_PER_DAY
                  D3SOURCE(destination,:) = D3SOURCE(destination,:) + &
                      flux/SEC_PER_DAY
                  if( allocated( D3FLUX_MATRIX(origin,destination)%p ) ) then
                     do j=1, SIZE(D3FLUX_MATRIX(origin,destination)%p)
                        D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) =      &
                             D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) + &
                             (SIGN( 1, D3FLUX_MATRIX(origin,destination)%p(j) ) * flux )
                     end do
                  endif
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
                case (iiBen)
                  D2SOURCE(origin,:) = D2SOURCE(origin,:) - &
                      flux/SEC_PER_DAY
                  D2SOURCE(destination,:) = D2SOURCE(destination,:) + &
                      flux/SEC_PER_DAY
#endif
              end select
            else ! origin==destination
              ! In this case the flux carries the proper sign
              select case ( iiSub )
                case (iiPel)
                  D3SOURCE(destination,:) = D3SOURCE(destination,:) + &
                      flux/SEC_PER_DAY
                  if( allocated( D3FLUX_MATRIX(origin,destination)%p ) ) then
                     do j=1, SIZE(D3FLUX_MATRIX(origin,destination)%p)
                        if( D3FLUX_MATRIX(origin,destination)%dir(j) == 1 ) then ! "A->B" => (out flow) => flux < ZERO => D3SINK
                           where( flux < ZERO )
                              D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) =     &
                                   D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) - flux
                           end where
                        else ! "A<-B" => (in flow) => flux > ZERO => D3SOURCE
                           where( flux > ZERO )
                              D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) =     &
                                   D3FLUX_FUNC( ABS(D3FLUX_MATRIX(origin,destination)%p(j)), : ) + flux
                           end where
                        end if
                     end do
                  endif
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
                case (iiBen)
                  D2SOURCE(destination,:) = D2SOURCE(destination,:) + &
                      flux/SEC_PER_DAY
#endif
              end select
            end if !origin <> destination

            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            !END compute
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            return
          end subroutine flux_vector
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          subroutine flux(grid_nr,iiSub,origin,destination,flow,error)
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use constants, only: RLEN, ZERO, SEC_PER_DAY
          use global_mem, only: LOGUNIT
          implicit none
          integer,intent(IN)                 :: grid_nr
          integer,intent(IN)                 :: iiSub
          integer,intent(IN)                 :: origin
          integer,intent(IN)                 :: destination
          real(RLEN),intent(IN)              :: flow
          integer,intent(INOUT),optional     :: error
          character(len=8)                   :: D23
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !BEGIN compute
#ifdef IFORT
          TESTNAN(flow,grid_nr,iiSub,origin,destination)
          CHECKFLUX(grid_nr,iiSub,origin,destination)
#endif
          if ( origin /= destination ) then
            select case ( iiSub )
              case (iiPel)
                D3SOURCE(origin,grid_nr) =    &
                         D3SOURCE(origin,grid_nr)-flow/SEC_PER_DAY
                D3SOURCE(destination,grid_nr) =    &
                         D3SOURCE(destination,grid_nr)+flow/SEC_PER_DAY
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
              case (iiBen)
                D2SOURCE(origin,grid_nr) =    &
                         D2SOURCE(origin,grid_nr)-flow/SEC_PER_DAY
                D2SOURCE(destination,grid_nr) =    &
                         D2SOURCE(destination,grid_nr)+flow/SEC_PER_DAY
#endif
            end select
          else
            ! In this case the flux carries the proper sign
            select case ( iiSub )
              case (iiPel)
                 D3SOURCE(destination,grid_nr) = D3SOURCE(destination,grid_nr) + &
                      flow/SEC_PER_DAY
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
              case (iiBen)
                 D2SOURCE(destination,grid_nr) = D2SOURCE(destination,grid_nr) + &
                      flow/SEC_PER_DAY
#endif
            end select
          endif
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !END compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          return
          end subroutine flux
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        subroutine sourcesink_flux_vector(iiSub,origin,destination,flux)
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            ! Implicit typing is never allowed
            !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            implicit none

            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            real(RLEN),intent(IN) :: flux(:)

            if ( destination ==0 ) then
              call flux_vector(iiSub,origin,origin,-flux)
            elseif ( origin ==0 ) then
              call flux_vector(iiSub,destination,destination,flux)
            else
             call  flux_vector(iiSub,origin,destination,flux)
            endif
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          end subroutine sourcesink_flux_vector
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function Source_D3_vector(iistate)
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! vector function to get actual rate of change in the pelagic
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use constants, only: RLEN, ZERO, SEC_PER_DAY
          implicit none
          integer, intent(IN) ::iistate
          real(RLEN) ::Source_D3_vector(size(D3SOURCE,DIM=2))
          integer :: i
          Source_D3_vector = ZERO
          Source_D3_vector(:) = D3SOURCE(iistate,:)*SEC_PER_DAY
        end function Source_D3_vector
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
        function Source_D2_vector(iistate)
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! vector function to get actual rate of change in the benthic
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use constants, only: RLEN, ZERO, SEC_PER_DAY
          implicit none
          integer, intent(IN) ::iistate
          real(RLEN) ::Source_D2_vector(size(D2SOURCE,DIM=2))
          integer :: i
          Source_D2_vector = ZERO
          Source_D2_vector = D2SOURCE(iistate,:)*SEC_PER_DAY 
        end function Source_D2_vector
#endif
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function source(iiSub,iibox,iistate)
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ! function to get actual rate of change
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use constants, only: RLEN, ZERO, SEC_PER_DAY
          implicit none
          real(RLEN)  ::Source
          integer, intent(IN)  ::iiSub
          integer, intent(IN)  ::iibox
          integer, intent(IN)  ::iistate
          integer :: i
          Source = ZERO
          if ( iiSub == iiPel )  then
             Source=D3SOURCE(iistate,iibox)*SEC_PER_DAY
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
          elseif ( iiSub == iiBen )  then
             Source=D2SOURCE(iistate,iibox)*SEC_PER_DAY
#endif
          endif
        end function source
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        subroutine unicflux(grid_nr,iiSub,origin,destination)
        !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use constants, only: RLEN, ZERO
          use global_mem, only: LOGUNIT
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ! Implicit typing is never allowed
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          implicit none
          integer,intent(IN)    :: grid_nr
          integer,intent(IN)    :: origin
          integer,intent(IN)    :: iiSub
          integer,intent(IN)    :: destination
          real(RLEN) :: tot
          character(len=20):: type
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !BEGIN compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          !END compute
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        return
      end subroutine unicflux
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      subroutine fixed_quota_flux_vector(mode,iiSub,which,origin, &
                                          destination,flux,collect)
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      use global_mem, only: LOGUNIT
      use constants, only: RLEN
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      ! Implicit typing is never allowed
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      implicit none
      integer,intent(IN) :: mode
      integer,intent(IN) :: iiSub
      integer,intent(IN) :: which
      integer,intent(IN) :: origin
      integer,intent(IN) :: destination
      real(RLEN),intent(IN),dimension(:) :: flux
      real(RLEN),intent(INOUT),dimension(:) :: collect
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      !BEGIN compute
      if ( origin> 0 .and.destination >0) then
         call flux_vector(iiSub,origin, destination,flux)
      else if ( origin > 0 ) then
         call flux_vector(iiSub,origin, origin,-flux)
      elseif ( destination > 0 ) then
         call flux_vector(iiSub,destination, destination,flux)
      elseif (iiSub < 0 ) then
         if ( mode==0)  return
         if ( sum(abs(flux)/(1.0D-80+abs(collect))-1.0D+00)> 1.0D-6) then
              if ( iiSub==-iiN) then
                write(LOGUNIT,'(''Warning: N:C quotum not fixed'')')
              elseif (iiSub==-iiP) then
                write(LOGUNIT,'(''Warning: P:C quotum not fixed'')')
              endif
              return
         endif
      endif      
      if ( mode==1 ) then
        if ( (which == origin) .and.(origin.ne.destination)) then
           collect=collect-flux
        else
           collect=collect+flux
        endif
      endif
      !END compute
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      end subroutine fixed_quota_flux_vector
      !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
! NaN-check routines
!-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#ifdef IFORT
! Important note: the intrinsic isnan is not allowed with strict F95
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          subroutine testnan_vector(array,iiSub,origin,destination)
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use global_mem, only: LOGUNIT
          implicit none
            real(RLEN),intent(IN)    :: array(:)
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            integer:: i=0
            do i=1,size(array)
              if (isnan(array(i))) then
                write(LOGUNIT,'(''at level:'',I4)') i
                write(LOGUNIT,'(''origin='',i4,'' destination='',i4)') &
                  origin,destination
                if ( iiSub== iiBen) then
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
                    write(LOGUNIT,*) "state value origin:",D2STATE(origin,i)
                    write(LOGUNIT,*) "state value destination:",D2STATE(destination,i)
#endif
                else
                    write(LOGUNIT,*) "state value origin:",D3STATE(origin,i)
                    write(LOGUNIT,*) "state value destination:",D3STATE(destination,i)
                endif
                STDERR 'Nan value in flux'
                stop 1002
              endif
            enddo
          end subroutine testnan_vector
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          subroutine testnan(scalar,grid_nr,iiSub,origin,destination)
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          use global_mem, only: LOGUNIT
          implicit none
            real(RLEN),intent(IN)    :: scalar
            integer,intent(IN) :: grid_nr
            integer,intent(IN) :: iiSub
            integer,intent(IN) :: origin
            integer,intent(IN) :: destination
            if (isnan(scalar)) then
               write(LOGUNIT,*) 'Nan value in scalar flux'
               write(LOGUNIT,'(''origin='',i4,'' destination='',i4)') origin,destination
               if ( iiSub == iiBen)  then
#if defined INCLUDE_BEN || defined INCLUDE_SEAICE
                    write(LOGUNIT,*) "Benthic state value origin:",D2STATE(origin,grid_nr)
                    write(LOGUNIT,*) "Benthic state value destination:",D2STATE(destination,grid_nr)
#endif
                 else
                    write(LOGUNIT,*) "Pelagic state value origin:",D3STATE(origin,grid_nr)
                    write(LOGUNIT,*) "Pelagic state value destination:",D3STATE(destination,grid_nr)
               endif
               stop "subroutine TESTNAN forced STOP"
            endif
          end subroutine testnan
          !-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#endif

!EOC
