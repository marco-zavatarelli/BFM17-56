#!/bin/bash
# the next line restarts using tclsh \
exec tclsh "$0" "$@"

#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: ReadFileContent
#
  proc ReadFileContent file {
# !INTERFACE:
#
# !INPUT PARAMETERS:
#		file: filename
# !OUTPUT PARAMETERS:
#		filecontent
# !DESCRIPTION:
#	  Procedure to read whole file in memory
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC
	set f1 [ open $file r ]
	set content [ read $f1]
	close $f1
	return $content
  }

#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: readm
#
  proc readm file  {
# !INTERFACE:
global VARS DEFINE
#
# !INPUT PARAMETERS:
#		 file: file with global definitions for model
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#      This routine read and digest all info read from a fiel which include
#       all info on state, output and other global vairables.
#       For state variables and output additional info is read to make it possible
#       to output the variables in netcdf files
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC


  catch { array unset VARS }
  set content [ ReadFileContent $file ]

  foreach jtem {state variable intvar } {
    foreach item {1d 3d 2d } {
     lappend VARS(reserved_words) $item-$jtem
    }
  }
  foreach jtem {state variable intvar flux } stem { 1 -1 -1 -1 } {
    foreach item {1d 3d 2d } {
    if { [ regexp "state|flux" $jtem ] && $item=="1d" } continue
    set neglect 0; set altZ "";
    foreach ktem {{ } {-if-exist.} {-Z.} {-define.} } {
     set start 0
     set mode 0
     while { [ regexp -start $start -indices -line "^ *$item-$jtem+ *$ktem*$" $content r ] } {
	set tline [ lrange [ string trim [ eval string range [ list $content ] $r ] ] 1 end ]
	catch { unset VARS(option) }
	while { [ llength $tline ] >0 } {
	  set h [ lsearch -all -regexp $tline {^-[A-Za-z0-9\-]} ]
	  if { [llength $h ] > 1 } {
	     set t [ lrange $tline 0 [ expr [ lindex $h 1 ] -1 ] ]
	     set tline [ lrange $tline [ lindex $h 1 ] end ]
	  } else {
	     set t [ join $tline ]
	     set tline {}
	  }
	  switch -regexp -- $t {
	    -if-exist {
	       set t [ lrange $t 1 end ]
	       if { [ regexp {^$} $t ] } \
		    { puts stdout "No name of env. var. after key word if-exist"; return 302 }
	       if { [ regexp {[^A-Za-z0-9\-\_\ ]} $t ] } \
		   { puts stdout "If use more than one env.var. format is  'ENV1 ENV2'";return 303 }
	       set i 0; foreach j $t {
		  if { [ lsearch -exact $DEFINE $j ] >=0 } { incr i }
	       }
	       set neglect [ expr 1 - ( $i== [ llength $t ] ) ]
	    }
	    -Z {
	       if { $item =="3d" && $jtem =="variable" } {
		 if { ![regexp -- {-Z *[^=]+= *[0-9.]+ *:[^:]+:.+} $t out ] } {
		   puts stdout "The definition of 3d-variables for other use then for pelagic is wrong"
		   puts stdout "format Z: 'non-existing-variable-name' = 'number' 'description' 'unit' "
		  return 303
		 } else {
		    regsub -all {=} $t ":" out; regsub -- "^-Z " $out "" out
		    set t [ split $out : ]; set altZ [ lindex 1 ]
		    set altZ [ string trim [ lreplace $t 2 2 ] ];append altZ " [ join [ lindex $t 2 ]]"
		 }
	       } else {
		 puts stdout "The Z: option can only be used in combination or 3d-variables"
		return 304
	       }
	    }
	    {-define} {
	       if { [ info exists VARS(option) ] } {
		 puts stdout "Error: option [ lindex $t 0 ] can only be used one time on a line"
		 return 304
	       }
	       set VARS(option) [ join [ lrange $t 1 end ] ]
	    }
	  }
	}
	set mode 1
	set start [ expr [ lindex $r 1 ] +1 ]
	set t 1
	while { $t } {
	  # find end of actual line
	  regexp -start $start -indices -line {^.*$} $content r
	  # set starting point for search after last line feed
	  set start [ expr [ lindex $r 1 ] +1 ]
	  # get a line:
	  set line [ eval string range [ list $content ] $r ]
	  # do not use empty lines and line starting with a comment
	  if { ![ regexp {^ *$|^ *#|^ *!} $line ] } {
	     if { [ regexp {^ *group} $line ] } {
	     # check on group states:
		incr mode 1
		if { [ set i [ ReadLine $mode $item group $line ]] > 0 } { return $i }
	     } elseif { [ regexp {^ *end} $line ] } {
		incr mode -1
		set t $mode
	     } else {
		if { [ set i [ ReadLine $mode $item $jtem $line $neglect $altZ ]] > 0 } { return $i }
	     }
	  }
	}
     }
     }
    }
  }
  set type variable
  foreach dim {3d 2d} {
    set ready 0
    set j 0
    while { !$ready } {
      set unit [ lindex $VARS($dim,$type,unit) $j ]
      set name [ lindex $VARS($dim,$type,name) $j ]
      if { $unit !="" } {
       if { ![regexp {\(} $name ] } {
	   lappend VARS($dim,diagnos,name) $name
	   lappend VARS($dim,diagnos,extname) [ lindex $VARS($dim,$type,extname) $j ]
	   lappend VARS($dim,diagnos,unit) $unit
       } else {
	   lappend VARS($dim,diaggrp,name) $name
	   lappend VARS($dim,diaggrp,extname) [ lindex $VARS($dim,$type,extname) $j ]
	   lappend VARS($dim,diaggrp,unit) $unit
       }
       lset VARS($dim,$type,unit) $j @
       lset VARS($dim,$type,extname) $j @
       lset VARS($dim,$type,name) $j @
      }
      incr j
      set ready [ expr $j >= [llength $VARS($dim,$type,unit) ] ]
    }
    foreach jtem {name extname unit} {
      regsub -all {\@|\@$} $VARS($dim,$type,$jtem) "" VARS($dim,$type,$jtem)
    }
  }
}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: ReadLine
#

# !INTERFACE:
#
proc ReadLine { mode dim type line { neglect 0 } { altZ "" } } {

# !USES:
global VARS

# !INPUT PARAMETERS:
#	     mode = 0: waiting/searching for a new dim-type --- end section in Global-Def file
#	     mode = 1: with in a dim-type -ened section.
#	     mode = 2: within in a group section
#	     dim = 1d , 2d or 3d
#	     type = state, variable,  int-var
#	     line = line with info
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#    Read a line of info and digest and save digested info in VARS
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

#check if state

set extname ""
set units ""
set constituents ""
set ifstate [ regexp state|group $type ]
set incldesc [ regexp -indices : $line r ]
if { $ifstate && !$incldesc } {
   puts stdout "error 1: all state var. must have a description"
   puts stdout "         In line no info found between ':'-characters"
   puts stdout "         info-line= $line"
   return 1
} elseif { !$incldesc } {
   if { [ regexp -indices \!|\# $line  r ] } {
      set extname [ string range $line [ expr [ lindex $r 1 ] +1 ] end ]
      set def [ string range $line 0 [ expr [ lindex $r 1 ] -1 ] ]
   } else {
      set def $line
   }
   regsub -all {\t|^ +|[\t ]+$} $def "" def
} else {
   set def [ string range $line 0 [ expr [ lindex $r 1 ] -1 ] ]
   regsub -all {\t|^ +|[\t ]+$} $def "" def
   if { $type == "flux" } {
      set tmp [ split $def = ]
      set def [ lindex $tmp 0 ]
      set sum [ lindex $tmp 1 ]
      if { [ set i [ eval_selec -check $sum ] ] >0 } { return $i }
      set selec [ eval_selec -eval $sum ]
      set selec [ expand_selec_fluxes $dim $selec ]
      if { [ llength $selec ] ==1 } { return $selec }
   }
   if { [ set i [ check_def_on_reserved_words_wrong_char $def ] ] > 0 } { return $i }
   set tmp [ string range $line [ expr [ lindex $r 1 ] +1 ] end ]
   regsub -all {\t|^ +| +$} $tmp "" tmp
   regsub -all {[\t ]*:[\t ]*} $tmp ":" tmp
   set units [ split $tmp : ]
   if { ![regexp group $type ] } {
     if { $mode !=2 } {
	set extname [ lindex $units 0 ]
	set units [ lrange $units 1 end ]
     } else {
       set extname $units
     }
   }
}

# get rid of the square brackets:
set nr_of_defs 0
set array ""
if { [ set with_brackets [ regsub -all {\[|\]} $def " " tmp ] ] == 2 } {
   # with square brackets
   regsub -all {^\t*|^ *| *$|\t*$} $tmp "" tmp
   set tmp [ split $tmp ]
   set j [ regexp group $type ]
   regsub -all { +$|\t+$} [ lindex $tmp $j ] "" name
   set constituents [ lindex $tmp [ incr j ] ]
   set array [ lindex $tmp [ incr j ] ]
   set nr_of_defs [ string length $constituents ]
   if { $mode< 2 && $nr_of_defs >1 \
	 && [ string length $constituents ] != [ llength $units ] } {
	puts stdout "error 2: list of units differs from the length of units"
        puts stdout "inputline = $line"
        puts stdout "list of constituents = $constituents"
        puts stdout "list of units = $units"
	return 2
   }
} elseif { !$with_brackets } {
   # without square brackets
   regsub -all {^\t*|^ *| *$|\t*$} $def "" name
} else {
  puts stdout "error 3: constituents NOT between square bracketes "
  return 3
}
if { $neglect == -1 } return
if  { $nr_of_defs ==0 && $mode < 2 } {
   if { $neglect } {
       if { $type== "state" } { lappend VARS($dim,$type,excluded) $name }
       return 0
   } elseif { $type =="flux" } {
     set option normal
     if { [ info exists VARS(option) ] } {
       set j [ regexp d2 $dim ]
       switch -- [ lindex $VARS(option) 0 ] {
	"vertical" {
	     set dim "2d"; set option $VARS(option)
	     set j [ expr 2* (1- [ regexp -- {->\ *\*+|\*\ <-} $line ] ) ]
	 }
	"perm2" { set dim "2d"; set option $VARS(option) }
	default { set j 0; set option $VARS(option) }
       }
       if { $j > 0 } {
	 switch $j {
	   1 { set tmp "$option can only be used in flux for 3d vars" }
	   2 { set tmp "With $option only sinbk/source type fluxes can be defined" }
	 }
	 puts stdout "error [ set j [expr $j +500 ] ]: $tmp"
	 return $j
       }
     }
     lappend VARS($dim,$type,option) $option
     lappend VARS($dim,$type,sum) $sum
     lappend VARS($dim,$type,selec) $selec
   }
   lappend VARS($dim,$type,name) $name
   if { $altZ !="" } {
     lappend VARS($dim,$type,extname) "__Z $altZ: $extname"
   } else {
     lappend VARS($dim,$type,extname) $extname
   }
   lappend VARS($dim,$type,unit) [ join $units]
} elseif {$mode < 2 } {
   regsub -all {.} $constituents "& " tmp
   foreach item $tmp jtem $units {
     if { $neglect } {
       lappend VARS($dim,$type,excluded) $name$item
     } else {
       lappend VARS($dim,$type,name) $name$item$array
       if { $altZ !="" } {
	  lappend VARS($dim,$type,extname) "__Z $altZ $extname"
       } else {
	  lappend VARS($dim,$type,extname) $extname
       }
       lappend VARS($dim,$type,unit) $jtem
     }
   }
} elseif { [regexp group $type ] } {
   set VARS(thisgroup,constituents) $constituents
   set VARS(thisgroup,units) $units
   lappend VARS($dim,group) $name
   lappend VARS($dim,member) ""
   lappend VARS($dim,constituents) $constituents
   if { [ info exists VARS(maxcon) ] } {
      regsub -all . $constituents "& " j
      foreach item $j {
       if { ![regexp $item $VARS(maxcon) ] } { append VARS(maxcon) $item }
      }
   } else {
     set VARS(maxcon) $constituents
   }
} else {
   lset VARS($dim,member) end [ eval list [ lindex $VARS($dim,member) end ] $name ]
   set tmp $VARS(thisgroup,constituents)
   if { [ regsub -all -- - $constituents "" remove ] } {
     if { ![ regsub $remove$ $tmp "" tmp ] } {
	puts stdout "error 4: constituent $constituents not at the end of group def."
	return 4
     }
     regsub -all . $remove "& " j
     foreach item $j {
       lappend VARS($dim,$type,excluded) $name$item
     }
   }
   regsub -all {.} $tmp "& " tmp
   set i 0

   set k [ llength $extname ]
   set k [ expr ( [ llength $extname ] == $k ) && ( $k > 1 ) ]
   foreach item $tmp {
     set jtem [ lindex $VARS(thisgroup,units) $i ]
     if { $neglect } {
       lappend VARS($dim,$type,excluded) $name$item
     } else {
       lappend VARS($dim,$type,name) $name$item
       if { $k } {
	 lappend VARS($dim,$type,extname) [ lindex $extname $i ]
       } {
	 lappend VARS($dim,$type,extname) [ join $extname ]
       }
       lappend VARS($dim,$type,unit) $jtem
       incr i
    }
  }
}

return 0
}

#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: make_f90
#
# !INTERFACE:
proc check_def_on_reserved_words_wrong_char { def } {

# !USES:
global VARS
# !INPUT PARAMETERS:
#		 def
# !DESCRIPTION:
#      function to check variable name on reserved words and wrong chracters
#      into files of the BFM-tree.
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC
   regsub -all {group |\[[\-a-z]+\]} $def "" tmp
   if { [ lsearch $VARS(reserved_words) $tmp ] >=0 } {
      puts stdout "error 10: found a reserved word on the wrong place"
      puts stdout "($tmp). Probably an 'end'-statement is missing!"
      return 10
   } elseif { [ regexp {[^A-Za-z0-9_()]} $tmp ] } {
      puts stdout "error 7: wrong chracter in name \"$def\""
      return 7
   }
}

#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: make_f90
#
# !INTERFACE:
proc make_f90 args {
global DEFINE

# !INPUT PARAMETERS:
#		mode = statemem    MoeuleMem.F90 is setupped
#		mode = allocmem    AllocateMem.f90 is setupped
#		mode = netcdfmem   set_var_info_bfm.F90 is setupped
#		mode = headerm     INLUCDE.h is setupped
# !DESCRIPTION:
#      function to combine info from .proto file with info derived from global definition file
#      into files of the BFM-tree.
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC


foralloptions item jtem $args {
   switch -regexp -- $item {
      -read    { set mfile $jtem }
      -from    { set fromdir $jtem }
      -to      { lappend ltodir $jtem }
      -actions { lappend ltodo $jtem }
      -D.      { lappend DEFINE [ string range $item 2 end] }
   }
}

if  { ![ file exists $mfile ] } {
   puts stdout "error 12:file $mfile does not exist!"
   return
}
if { [ set i [ readm $mfile ] ] >0 } { return $i }

if { [ llength $ltodir ] != [ llength $ltodo ] } {
  puts stdout "error 13: the number of calls to options -to  and -actions are not equal"
  return
}


foreach todir $ltodir  todo $ltodo {
  foreach mode $todo {
    set ext F90
    switch -- $mode {
       statemem  { set infile ModuleMem.proto }
       allocmem  { set infile AllocateMem.proto; set ext F90 }
       netcdfmem { set infile set_var_info_bfm.proto }
       headermem { set infile INCLUDE.proto; set ext h }
    }
  
    # delete existing file with F90 or f90 extension
    if { ![catch {glob [ file join $todir [file rootname $infile].\[fF\]90 ] }  tmp ] } \
			   { file delete $tmp }
    regsub proto$ $infile $ext outfile
    if { [ info exists todir ] } {
      if { ![file exists $todir] } {
	  puts stdout "error 11: directory $todir does not exist"
	  return 11
      }
      set outfile [ file join $todir $outfile ]
    }
    PrintSetup -openfile $outfile

    Section -reset
    Section -incr
    Section -incr
    Section -incr


    if { [ info exists fromdir ] } \
       { set infile [ file join $fromdir $infile ] }
    set proto [ ReadFileContent $infile ]

    set error 0
    set start 0
    while { [ regexp -indices -start $start -- {\%[a-zA-Z0-9\-\ \!]+} $proto r ] } {
      PrintLine  -block "[ string range $proto $start [ expr [ lindex $r 0 ] -1 ] ]"
      set tmp [ eval string range [ list $proto ] $r ]
      if { [ regexp {^\%\!} $tmp ] } {
	# remove comment lines ( lines starting with %!) in the proto files
	# these line include information for the programmers
	regexp -line -indices -start [ lindex $r 1 ] -- {.*$} $proto r
      } else {
	set error [ eval make_output $tmp ]
	if { $error > 0 } break
      }
      set start [ expr [ lindex $r 1 ] +1 ]
    }
    if { $error > 0 } {
      PrintSetup -errorclose $outfile
    } else {
      PrintLine -block [ string range $proto $start end ]
      PrintSetup -closefile
    }
  }
}
return 0

}

#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE:
#
proc make_output { input { what "" }  } {

# !INTERFACE:
#
global VARS

# !INPUT PARAMETERS:
#	input= command which describe which code have to be generated
#
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#	    generate lines with code for ModuleMem.F90,AllocateMem.f90, set_var_bio.F90 and INCLUDE.h
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC


regsub \% $input "" mode
set tmp [ split $mode - ]
set dim [ lindex $tmp 0]
set type [ lindex $tmp 1 ]
switch -- $mode {
   3d-diagnos-desc -
   2d-diagnos-desc -
   3d-state-desc -
   2d-state-desc {
     if { [ info exists VARS($dim,$type,name) ] } {
        set tmp [ format "! %10s %60s %15s" "$dim name" "description" "unit" ]
        PrintLine -block $tmp; PrintLine -print ""
        set tmp "! [string repeat - 10 ] [string repeat - 60 ] [ string repeat - 15 ]"
        PrintLine -block $tmp; PrintLine -print ""
        foreach name $VARS($dim,$type,name) extname $VARS($dim,$type,extname) unit $VARS($dim,$type,unit) {
          set tmp [ string range $extname [ expr [string first ":" $extname ] +1] end ]
          set tmp [ format "! %10s %60s %15s" $name $tmp $unit ]
          PrintLine -block "$tmp";PrintLine -print ""
        }
     }
   }
   3d-diaggrp-desc -
   2d-diaggrp-desc {
     if { [ info exists VARS($dim,$type,name) ] } {
       foreach name $VARS($dim,$type,name) extname $VARS($dim,$type,extname) unit $VARS($dim,$type,unit) {
         regsub -all {\(|\)} $name " " tmp
         set grpname [ lindex $tmp 1 ];set root [ lindex $tmp 0 ]
         set memberlist [ searchforgroup $dim $grpname ]
         regsub $grpname $extname "\%(&)" sext
         foreach member $memberlist {
	   regsub % $sext $member tmp
	   set tmp [ format "! %10s %60s %15s" ${root}(ii$member) $tmp $unit ]
	   PrintLine -block "$tmp";PrintLine -print ""
         }
       }
     }
   }
   3d-flux-nr -
   2d-flux-nr -
   3d-diagnos-nr -
   2d-diagnos-nr -
   3d-state-nr -
   2d-state-nr {
     if { [ info exists VARS($dim,$type,name) ] } {
	if { $type == "diagnos" } {
	  set l [ llength $VARS($dim,$type,name) ]
          if { [ info exists VARS($dim,diaggrp,name) ] } {
	     foreach name $VARS($dim,diaggrp,name) {
	        regsub -all {\(|\)} $name " " tmp; set grpname [ lindex $tmp 1 ]
	        incr l [ llength [ searchforgroup $dim $grpname ] ]
	     }
          }
	  if { [ info exists VARS(ex_$type,$dim,index) ] } {
	     set i 0
	     foreach item $VARS(ex_$type,$dim,index) {
		lset VARS(ex_$type,$dim,index) $i $l
		set l [ expr $item +$l ]
		incr i
	     }
	  } else {
	    set VARS(ex_$type,$dim,spec) none
	  }
	  PrintLine -print $l
	} else {
	  PrintLine -print [ llength $VARS($dim,$type,name) ]
	}
     } else {
	 PrintLine -print 0
     }
   }
   3d-state-array -
   2d-state-array -
   3d-diagnos-array -
   2d-diagnos-array {
      if { [ info exists VARS($dim,$type,name) ] } {
	set TYPE [ string toupper $type ]
	regsub d $dim "" i
	PrintLine -print "real(RLEN),public,pointer,dimension(:,:) :: D${i}${TYPE}"
	if { $type == "state" } {
	  set tmp SOURCE
	  PrintLine -print "real(RLEN),public,pointer,dimension(:,:,:) :: D${i}${tmp}"
	  set tmp SINK
	  PrintLine -print "real(RLEN),public,pointer,dimension(:,:,:) :: D${i}${tmp}"
	  set tmp STATETYPE
	  PrintLine -print "integer,public,pointer,dimension(:) :: D${i}${tmp}"
	}
      }
   }
   3d-state-field-array {
      if { [ regexp "^$" $what ] } { puts stdout "error: No field name given";return 401 }
      if { [ info exists VARS(ex_diagnos,2d,spec) ] } {
	 if { $VARS(ex_diagnos,2d,spec) == "none" } {
	    puts stdout "error: wrong sequence this variable has to be defined"
	    puts stdout "before in ModuleMem %2d-diagnos-nr is called"
	    return 206
	 }
      }
      set SPEC [ string toupper $what ]
      PrintLine -print "real(RLEN),public,pointer,dimension(:,:) :: PEL${SPEC}"
      lappend VARS(ex_diagnos,2d,spec) $SPEC
      lappend VARS(ex_diagnos,2d,index) [ llength $VARS($dim,$type,name) ]
   }

   3d-diaggrp-pp -
   2d-diaggrp-pp {
     if { [ info exists VARS($dim,$type,name) ] } {
       regsub -all {^| } $VARS($dim,$type,name) "&pp" tmp
       regsub -all {\(} $tmp "(ii" tmp
       PrintLine -print "integer,public      :: [join $tmp {, } ]"
     }
   }
   3d-diagnos-pp -
   2d-diagnos-pp -
   3d-state-pp -
   2d-state-pp {
     regsub -all {^| } $VARS($dim,$type,name) "&pp" tmp
     set i 0; set n [ llength $VARS($dim,$type,name) ]
     while { $i <$n } { lset tmp $i "[lindex $tmp $i]=[ incr i ]" }
     if { [ info exists VARS($dim,$type,excluded) ] } {
	regsub -all {^| } $VARS($dim,$type,excluded) "&pp" excl
	regsub -all { |$} $excl "=0&" excl
	eval lappend tmp $excl
     }
     PrintLine -print "integer,parameter,public      :: [join $tmp {, } ]"
   }
   3d-diaggrp-pointer -
   2d-diaggrp-pointer {
     if { [ info exists VARS($dim,$type,name) ] } {
       foreach name $VARS($dim,$type,name) {
         regsub -all {\(|\)} $name " " tmp; lappend pplist [ lindex $tmp 0 ]
       }
       PrintLine -print "real(RLEN),public,dimension(:,:),pointer  :: [join $pplist {, } ]"
     }
   }
   3d-diagnos-pointer -
   2d-diagnos-pointer -
   3d-state-pointer -
   2d-state-pointer {
     set tmp $VARS($dim,$type,name)
     PrintLine -print "real(RLEN),public,dimension(:),pointer  :: [join $tmp {, } ]"
   }
   3d-Z-pointer {
     set tmp ""
     foreach item $VARS($dim,diagnos,extname) {
       if { [ regexp \_\_Z $item ] } {
	 set i [ lindex $item 1 ]
	 if { [ lsearch -exact $tmp $i ] < 0 } { lappend tmp $i }
       }
     }
     if { $tmp == "" } return
     PrintLine -crepeat "-="
     PrintLine -cprint "! Definition(s) of alternative Z-axis"
     PrintLine -print ""
     PrintLine -print "real(RLEN),public,dimension(:),pointer  :: [join $tmp {, } ]"
     PrintLine -crepeat "-="
   }
   3d-state-field-pointer {
     if { [ regexp "^$" $what ] } { puts stdout "error: No field name given";return 401 }
     set SPEC [ string range $what 0 2 ]
     set tmp $VARS($dim,$type,name)
     set i 0; set n [ llength $VARS($dim,$type,name) ]
     while { $i <$n } { lset tmp $i "j${SPEC}[lindex $tmp $i]";incr i }
     PrintLine -print "real(RLEN),public,dimension(:),pointer  :: [join $tmp {, } ]"
   }
   3d-diaggrp-assign-pp -
   2d-diaggrp-assign-pp {
     if { [ info exists VARS($dim,$type,name) ] } {
       set i [ llength $VARS($dim,diagnos,name) ]
       foreach name $VARS($dim,$type,name) {
         regsub -all {\(|\)} $name " " tmp
         set grpname [ lindex $tmp 1 ];set root [ lindex $tmp 0 ]
         set memberlist [ searchforgroup $dim $grpname ]
         foreach member $memberlist {
	    PrintLine -print "pp${root}(ii$member)=[ incr i ]"
         }
       }
     }
   }
   3d-diaggrp-alloc-pointer -
   2d-diaggrp-alloc-pointer {
     if { [ info exists VARS($dim,$type,name) ] } {
        regsub d $dim "" i
        set TYPE DIAGNOS
        foreach name $VARS($dim,diaggrp,name) {
	  regsub -all {\(|\)} $name " " tmp
	  set root [ lindex $tmp 0 ]; set grpname [ lindex $tmp 1 ]
	  set memberlist [ searchforgroup $dim $grpname ]
	  PrintLine -print "$root => D$i${TYPE}(pp${root}(ii[ lindex $memberlist 0 ]):\
						pp${root}(ii[ lindex $memberlist end ]),:)"
	  PrintLine -print "$root=ZERO"
        }
     }
   }
   3d-diagnos-alloc-pointer -
   2d-diagnos-alloc-pointer -
   3d-state-alloc-pointer -
   2d-state-alloc-pointer {
      regsub d $dim "" i
      set TYPE [ string toupper $type ]
      foreach name $VARS($dim,$type,name) {
	 PrintLine -print "$name => D$i${TYPE}(pp$name,:); $name=ZERO"
      }
   }
   3d-state-field-alloc-pointer {
     if { [ regexp "^$" $what ] } { puts stdout "error: No field name given";return 401 }
     set spec [ string range $what 0 2 ]
     set SPEC [ string toupper $what ]
     set tmp $VARS($dim,$type,name)
     if { ![ info exists VARS(ex_diagnos,2d,index) ] } {
	puts stdout "error: for allocating field arrays you need to define at them in ModuleMem.F90"
	return 203
     }
     set i [ lsearch $VARS(ex_diagnos,2d,spec) $SPEC ]
     if { $i <0 } {
       puts stdout "error: $SPEC was not defined in ModuleMem.F90"
     }
     set n [ lindex $VARS(ex_diagnos,2d,index) $i ]
     set m [ llength $VARS($dim,$type,name) ]
     PrintLine -print "PEL${SPEC} => D2DIAGNOS($n\+1:$n\+$m,:); PEL$SPEC=ZERO"
     foreach name $VARS($dim,$type,name) {
	 PrintLine -print "j${spec}$name => D2DIAGNOS($n+pp$name,:); j${spec}$name=ZERO"
     }
   }

   3d-diaggrp-header -
   2d-diaggrp-header {
     if { [ info exists VARS($dim,$type,name) ] } {
      regsub d $dim "" i
       set TYPE DIAGNOS
       foreach name $VARS($dim,diaggrp,name) {
	  regsub -all {\(|\)} $name " " tmp
	  set root [ lindex $tmp 0 ]; set grpname [ lindex $tmp 1 ]
	  set memberlist [ searchforgroup $dim $grpname ]
	  PrintLine -block "#define ${root}(A,B) D$i${TYPE}(pp${root}(A),B)"
	  PrintLine -print ""
       }
     }
   }
   3d-diagnos-header -
   2d-diagnos-header -
   3d-state-header -
   2d-state-header {
      regsub d $dim "" i
      set TYPE [ string toupper $type ]
      foreach name $VARS($dim,$type,name) {
	 PrintLine -block "#define ${name}(A) D$i${TYPE}(pp${name},A)"
	 PrintLine -print ""
      }
   }
   3d-state-field-header {
     if { [ regexp "^$" $what ] } { puts stdout "error: No field name given";return 401 }
     set spec [ string range $what 0 2 ]
     set SPEC [ string toupper $what ]
     set tmp $VARS($dim,$type,name)
     if { ![ info exists VARS(ex_diagnos,2d,index) ] } {
	puts stdout "error: for allocating field arrays you need to define them first in ModuleMem.F90"
	return 203
     }
     set i [ lsearch $VARS(ex_diagnos,2d,spec) $SPEC ]
     if { $i <0 } {
       puts stdout "error: $SPEC was not defined in ModuleMem.F90"
     }
     set n [ lindex $VARS(ex_diagnos,2d,index) $i ]
     set m [ llength $VARS($dim,$type,name) ]
     PrintLine -block "#define PEL${SPEC}(A,B) D2DIAGNOS($n+A,B)"
     PrintLine -print ""
     foreach name $VARS($dim,$type,name) {
	 PrintLine -block "#define j${spec}${name}(B) D2DIAGNOS($n+pp$name,B)"
	 PrintLine -print ""
     }
   }

   3d-group-header -
   2d-group-header {
     regsub d $dim "" i
     set TYPE STATE
     foreach name $VARS($dim,group) {
	 PrintLine -block "#define ${name}(A,B) D$i${TYPE}(pp${name}(A,B),:)"
	 PrintLine -print ""
     }
   }
   if-exist-header {
     if { [ info exist VARS(if-exist) ] } {
       foreach name $VARS(if-exist) {
	   PrintLine -block "#define ${name} 1"
	   PrintLine -print ""
       }
     }
   }
   3d-diaggrp-string -
   2d-diaggrp-string {
     if { [ info exists VARS($dim,$type,name) ] } {
        set type_nr [ llength $VARS(string,index) ]
        set i [ expr 1 + 3* [ lsearch {3d 2d} $dim ] + 2 ]
        if { $type_nr != $i } {
  	  puts stdout "error with sequence"
	  return 201
        }
        set var var_names
        set extvar var_long
        set unitv var_units
        set i [ lindex $VARS(string,index) end ]
        foreach name $VARS($dim,$type,name) extname $VARS($dim,$type,extname) \
				    unit $VARS($dim,$type,unit) {
	  regsub -all {\(|\)} $name " " tmp
	  set grpname [ lindex $tmp 1 ];set root [ lindex $tmp 0 ]
	  set memberlist [ searchforgroup $dim $grpname ]
	  regsub $grpname $extname "\%(&)" sext
	  foreach member $memberlist {
	    regsub % $sext $member tmp
	    incr i
	    PrintLine -print "${var}($i)=\"${root}(ii$member)\""
	    PrintLine -print "${extvar}($i)=\"$tmp\""
	    PrintLine -print "${unitv}($i)=\"$unit\""
	  }
        }
        if { $i > 0 } {
  	  lset VARS(string,index) end $i
        }
     }
   }
   3d-flux-string -
   2d-flux-string -
   3d-diagnos-string -
   2d-diagnos-string -
   3d-state-string -
   2d-state-string {
     if { ![ info exists VARS(string,index) ] } {
	  set VARS(string,index) 0
     }
     set type_nr [ llength $VARS(string,index) ]
     set i [ expr 1 + 3* [ lsearch {3d 2d} $dim ] + [ lsearch {state diagnos flux} $type ] ]
     if { $type_nr != $i } {
	puts stdout "error with sequence"
	return 201
     }
     if { ![ info exists VARS($dim,$type,name) ] } {
	lappend VARS(string,index) [ lindex $VARS(string,index) end ]
     } else {
	set var var_names
	set extvar var_long
	set unitv var_units
	set i [ lindex $VARS(string,index) end ]
	foreach name $VARS($dim,$type,name) extname $VARS($dim,$type,extname) \
				    unit $VARS($dim,$type,unit) {
	   incr i
	   PrintLine -print "${var}($i)=\"$name\""
	   PrintLine -nobreak "${extvar}($i)=\"$extname\""
	   PrintLine -print ""
	   PrintLine -print "${unitv}($i)=\"$unit\""
	}
	lappend VARS(string,index) $i
	set VARS(string,mode_last) $mode
     }
   }
   3d-state-field-string {
      if { [ regexp "^$" $what ] } { puts stdout "error: No field name given";return 401 }
      if { ![info exist VARS(string,mode_last) ] } {
	puts stdout "error: \%$mode on wrong place in AllocateMem.proto file"
	return 204
      } elseif { $VARS(string,mode_last) != "2d-diagnos-string" } {
	puts stdout "error: \%$mode must appear directly after the %2d-diagnos-string in the AllocateMem.proto"
	return 205
      }
      set spec [ string range $what 0 2 ]
      set SPEC [ string toupper $what ]
      set var var_names
      set extvar var_long
      set unitv var_units
      set i [ lindex $VARS(string,index) end ]
      foreach name $VARS($dim,$type,name) extname $VARS($dim,$type,extname) \
				    unit $VARS($dim,$type,unit) {
	incr i
	PrintLine -print "${var}($i)=\"j$spec$name\""
	PrintLine -print "${extvar}($i)=\"flux of $extname at $SPEC\""
	set j [ regexp {/[A-Za-z]+[0-9]+} $unit lenunit ]  
	if { ![ regexp {/[A-Za-z]+} $unit ] } {
	  puts stdout "no length unit in unit ($unit) for $name"
	  puts stdout "adaptation of unit from mass to flux impossible"
	  puts stdout "replace \"???\" by proper units in General\/set_var_info_bfm.f90"
	  set unit "???/day"
	} elseif  { $j ==0 } {
           regsub / $unit " m/" unit
	   append unit /day
	} else {
	  regexp {[0-9]+} $lenunit lenpower
	  incr lenpower -1
	  regsub {[0-9]+} $lenunit $lenpower lenunit
	  regsub {/[A-Za-z]+[0-9]+} $unit $lenunit unit
	  append unit /day
	}

	PrintLine -print "${unitv}($i)=\"$unit\""
      }
      if { $i > 0 } {
	lset VARS(string,index) end $i
      }
   }
   dd-string-index {
       set j 0
       set i 0
       foreach item {Pel Ben} {
	  foreach jtem  {State Diag Flux} {
	    incr j
	    incr i
	    PrintLine -print "st${item}${jtem}S=$j"
	    set j [lindex $VARS(string,index) $i ]
	    PrintLine -print "st${item}${jtem}E=$j"
	  }
       }
   }
   3d-Z-alloc {
     set tmp ""
     foreach item $VARS($dim,diagnos,extname) {
       if { [ regexp ^__Z $item ] } {
	 set i [ lindex $item 1 ]
	 if { [ lsearch -exact $tmp $i ] < 0 } {
	   if { $tmp == "" } {
	      PrintLine -crepeat "-="
	      PrintLine -cprint "!Allocations(s) of and assigning values to alternative  Z-axis"
	      PrintLine -print ""
	   }
	   lappend tmp $i
	   PrintLine -print ""
	   PrintLine -print "allocate(${i}(1:NO_BOXES_Z),stat=status)"
	   PrintLine -print "if (status /= 0) call error_msg_prn(ALLOC,\"AllocateMem\", \"$i\")"
#	   PrintLine -print
#           PrintLine -print "call calc_sigma_depth(NO_BOXES_Z,2.0D+00,0.3D+00,${i})"
#   PrintLine -print "${i}(1)=real([ lindex $item 2 ])/real(NO_BOXES_Z-1)"
#   PrintLine -print "do status=2,NO_BOXES_Z"
#   PrintLine -print "${i}(status)=${i}(status-1)+real([ lindex $item 2 ])/real(NO_BOXES_Z-1)"
#   PrintLine -print "enddo"
	   PrintLine -crepeat "-="
	 }
       }
     }
   }
   3d-diagnos-alloc -
   2d-diagnos-alloc -
   3d-state-alloc -
   2d-state-alloc {
     if { [ info exist VARS($dim,$type,name) ] } {
       Section -incr
       set TYPE [ string toupper $type ]
       regsub d $dim "" i
       set j ""; if { $dim =="2d" } { set j "_XY" }
       PrintLine -print ""
       PrintLine -print "allocate(D$i${TYPE}(1:NO_D${i}_BOX_${TYPE}S,1:NO_BOXES$j),stat=status)"
       PrintLine -print "if (status /= 0) call error_msg_prn(ALLOC,\"AllocateMem\", \"D$i$TYPE\")"
       PrintLine -print "D$i${TYPE} = ZERO"
       if { $type == "state" } {
	 set tmp SOURCE
	 PrintLine -print "allocate(D$i${tmp}(1:NO_D${i}_BOX_STATES,1:NO_D${i}_BOX_STATES,1:NO_BOXES$j),stat=status)"
	 PrintLine -print "if (status /= 0) call error_msg_prn(ALLOC,\"AllocateMem\", \"D$i$tmp\")"
	 PrintLine -print "D$i$tmp = ZERO"
	 set tmp SINK
	 PrintLine -print "allocate(D$i${tmp}(1:NO_D${i}_BOX_STATES,1:NO_D${i}_BOX_STATES,1:NO_BOXES$j) ,stat=status)"
	 PrintLine -print "if (status /= 0) call error_msg_prn(ALLOC,\"AllocateMem\", \"D$i$tmp\")"
	 PrintLine -print "D$i$tmp = ZERO"
	 set tmp STATETYPE
	 PrintLine -print "allocate(D$i${tmp}(1:NO_D${i}_BOX_${TYPE}S ),stat=status)"
	 PrintLine -print "if (status /= 0) call error_msg_prn(ALLOC,\"AllocateMem\",\"D$i$tmp\")"
	 PrintLine -print "D$i$tmp = ZERO"
       }
       Section -decr
     }
   }
   1d-intvar-alloc -
   2d-intvar-alloc -
   3d-intvar-alloc -
   3d-variable-alloc -
   2d-variable-alloc -
   1d-variable-alloc {
      set i ""; if { $dim =="2d" } { set i "_XY" }
      foreach name $VARS($dim,$type,name) {
	 set m [ expr [ regsub -all {\(|\)} $name " " tmp ]/2 + 2* [ regexp 2|3 $dim ] ]
	 if { $m > 0 } {
	    set base [ lindex $tmp 0 ]
	    set indexname [ lindex $tmp 1 ]
	    if { [ set l [ lsearch $VARS(2d,group) $indexname ]] <0 } {
		set l [ lsearch $VARS(3d,group) $indexname ]
	    }
	    if { $l >=0 } { set l ii } { set l "" }
	 }
	 switch -- $m {
	    3 { PrintLine -print "allocate(${base}(1:$l$indexname,\
				 1:NO_BOXES$i),stat=status); ${base} = ZERO"
	    }
	    2 { PrintLine -print "allocate(${name}(1:NO_BOXES$i),\
				      stat=status); $name = ZERO"
	    }
	    1 { PrintLine -print "allocate(${base}(1:$l$indexname\
			       ),stat=status); ${base} = ZERO"
	    }
	 }
      }
   }
   dd-flux-alloc {
     set nn 0
     set mm 0
     foreach dim {2d 3d} {
	if { [ info exists VARS($dim,$type,selec) ] } {
	  incr nn [ llength $VARS($dim,$type,selec) ]
	  foreach jtem $VARS($dim,$type,selec) {
	     incr mm [ llength [ lindex $jtem 0 ] ]
	  }
	}
     }
     PrintLine -print "allocate(flx_calc_nr(0:$nn),stat=status)"
     PrintLine -print "allocate(flx_CalcIn(1:$nn),stat=status)"
     PrintLine -print "allocate(flx_option(1:$nn),stat=status)"
     PrintLine -print "allocate(flx_t(1:$mm),stat=status)"
     PrintLine -print "allocate(flx_SS(1:$mm),stat=status)"
     PrintLine -print "allocate(flx_states(1:$mm),stat=status)"
     PrintLine -print "allocate(flx_ostates(1:$mm),stat=status)"
     PrintLine -print "flx_calc_nr(0)=0"
     if { [ info exists VARS(3d,$type,selec) ] } { set i [ llength $VARS(3d,$type,selec) ] } { set i 0 }
     PrintLine -print "flx_cal_ben_start=$i"
   }
   3d-flux-fill -
   2d-flux-fill {

#    Important:
#    In the AllocMem.proto file first 3d-flux-fill have to be called!
#

     set i 0; set j 0
     if { [ info exist VARS($dim,$type,selec) ] } {
       if { [ info exists VARS(alloc,flux) ] } { scan $VARS(alloc,flux) "%d %d" i j }
       foreach item $VARS($dim,$type,selec) jtem $VARS($dim,$type,name) \
	       ktem $VARS($dim,$type,sum) ltem $VARS($dim,$type,option) {
	 incr i
	 set tmp [ lindex {iiPel iiBen} [ lsearch {3d 2d} $dim ] ]
	 set tmp2 [ lindex {0 1 2 3} [ lsearch {normal specific perm2 vertical} [ lindex $ltem 0 ] ] ]
	 if {$ltem == "perm2" } { set tmp iiPel }
	 regsub -all  {^| } [ lindex $item 3 ] "&pp" L_ostates
	 if { $tmp2 == 3 } { regsub -all {[A-Za-z0-9]+} $L_ostates [ lindex $ltem 1 ] L_ostates  }
	 PrintLine -print ""
	 PrintLine -cprint "! $jtem=$ktem        ($ltem flux): "
	 PrintLine -print ""
	 PrintLine -print "flx_calc_nr($i)= [ expr $j + [ llength [ lindex $item 0 ] ] ];\
			   flx_CalcIn($i)=$tmp; flx_option($i)=$tmp2"
	 foreach t [ lindex $item  0] SS [ lindex $item 1 ] \
			   states [ lindex $item 2 ] ostates $L_ostates  {
	    incr j
	    set tmp [ lindex {1 0} [ lsearch {sink source} $SS ] ]
	    PrintLine -print "flx_t($j)=${t}1.00;flx_SS($j)=$tmp;\
			      flx_states($j)=pp$states;flx_ostates($j)=$ostates"
	 }
       }
     }
     set VARS(alloc,flux) [ list $i $j ]
   }
   constituent {
      regsub -all {.} $VARS(maxcon) "& " tmp
      set tmp [ string toupper $tmp ]
      set i 0; set n [ llength $tmp ]
      while { $i <$n  } { lset tmp $i "ii[lindex $tmp $i]=[ incr i ]" }
      PrintLine -print "integer,parameter,public     :: [join $tmp {, } ]"
   }
   3d-group-parameter -
   2d-group-parameter {
     foreach item $VARS($dim,group) jtem $VARS($dim,member) {
      set tmp $jtem
      set i 0; set n [ llength $tmp ]
      while { $i <$n } { lset tmp $i "ii[lindex $tmp $i]=[ incr i ]" }
      PrintLine -print "integer,parameter,public     :: ii$item=[ llength $jtem], [join $tmp {, } ]"
     }
   }
   3d-group-function-name -
   2d-group-function-name {
     regsub -all {^| } $VARS($dim,group) "&pp" tmp
     set tmp [ eval list $tmp $VARS($dim,group) ]
     PrintLine -print "public [join $tmp {, } ]"
   }
   3d-groupfunctions -
   2d-groupfunctions {
      make_group_function $dim "pp"
      make_group_function $dim ""
   }
   1d-intvar -
   3d-intvar -
   2d-intvar -
   1d-variable -
   3d-variable -
   2d-variable {
     set m -1
     set j 0;  set n [ llength $VARS($dim,$type,name) ]
     foreach item $VARS($dim,$type,name) jtem $VARS($dim,$type,extname) ktem $VARS($dim,$type,unit) {
       set mold $m
       set m [ expr [ regexp {\(} $item ] + [ regexp 2|3 $dim ] ]
       if { $m != $mold } {
	   if {$mold>=0} {
	      PrintLine -block "      \!$keepextname"
	      PrintLine -print ""
	      Section -decr
	   }
	   set tmp "real(RLEN)"; if { [regexp intvar $type ] } { set tmp integer }
	   switch -- $m {
	      0 { PrintLine -print "$tmp,public                                    :: &" }
	      1 { PrintLine -print "$tmp,public,dimension(:),allocatable           :: &" }
	      2 { PrintLine -print "$tmp,public,dimension(:,:),allocatable         :: &" }
	   }
	   Section -incr
       } else {
	  PrintLine -print ",& \!$keepextname"
       }
       incr j
       regexp {[0-9A-Za-z_]+} $item tmp
       PrintLine -nonewline $tmp
       set keepextname $jtem
       if { $ktem !="" } { append keepextname " ($ktem)" }
     }
     if {$m>=0} {
	 PrintLine -block "      \!$keepextname"
	 PrintLine -print ""
	 Section -decr
     }
   }
}
return 0

}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: make_group_function
#
# !INTERFACE:
#
proc make_group_function { dim pre } {

# !USES:
#
global VARS

# !INPUT PARAMETERS:
#		    dim = 2d ,3d
#		    pre = "", pp  ( stands resp. for pointer function, index function )
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#	function are printed in file with which index of an array can be caluclated of pointer can be
#	set.
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

foreach groupname $VARS($dim,group) members $VARS($dim,member) constituents $VARS($dim,constituents) {
  set mis_components "[ lindex $members 0 ][string range $constituents 0 0 ]"
  set representative [lindex $members 0 ]
  set components [ lfind -glob -all $VARS($dim,state,name) \
					$representative\[$VARS(maxcon)\] ]
  if { $components == "" } { set components $mis_components }
  regsub $representative [ lindex $components 0 ] "" firstc
  PrintLine -print ""
  PrintLine -print "function $pre${groupname}(n,constituent)"
  Section -incr body
  PrintLine -print ""
  PrintLine -crepeat "-="
  PrintLine -print " ! Implicit typing is never allowed"
  PrintLine -crepeat "-="
  PrintLine -print "IMPLICIT NONE"
  PrintLine -print ""
  if { $pre == "pp" } {
    PrintLine -print "integer ::$pre$groupname"
   } else {
    PrintLine -print "real(RLEN),dimension(:),pointer ::$pre$groupname"
   }
  PrintLine -print "integer, intent(IN) ::n"
  PrintLine -print "integer, intent(IN) ::constituent"
  PrintLine -print ""
  if { $pre == "pp" } {
    catch { unset k }; set l 0
    regsub -all {^| } $members &pp tmp
    regsub -all { |$} $tmp $firstc& tmp
    PrintLine -print "integer,dimension([llength $members])  :: referto=(/[join $tmp , ]/)"
    unset tmp
    foreach member $members {
       set components [ lfind -glob -all $VARS($dim,state,name) \
 				$member\[$VARS(maxcon)\] ]
       if { $components == "" && ![info exists tmp] } { set components $mis_components }
       regexp {[a-z]+$} $components j					
       set l [ expr [ string first $j $VARS(maxcon) ] +1 ]
       lappend tmp $l
    }
    PrintLine -print "integer,dimension([llength $members]) :: const_max=(/[join $tmp , ]/)"
    unset tmp
    set k [ string length $VARS(maxcon) ]
    regsub -all . $VARS(maxcon) "0 " tmp
    set i 0
    regsub -all . $constituents "& " split_constituents
    foreach constituent $split_constituents {
      lset tmp [ set j [ string first $constituent $VARS(maxcon) ] ] $i
      if { $j >0 } { set l $i }
      incr i
    }
    PrintLine -print "integer,dimension($k) :: constituent_add=(/[join $tmp , ]/)"
    PrintLine -print ""
    PrintLine -print "if ( constituent <=const_max(n) ) then"
    Section -incr body
    PrintLine -print "$pre$groupname=referto(n)+ constituent_add(constituent)"
    Section -decr body
    PrintLine -print "else"
    Section -incr body
    PrintLine -print "$pre$groupname=0"
    Section -decr body
    PrintLine -print "endif"
  } else {
    regsub d $dim "" dim2
    PrintLine -print "$pre$groupname => D${dim2}STATE(pp${groupname}(n,constituent),:)"
  }
  PrintLine -print ""
  Section -decr body
  PrintLine -print "END function"
}

}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: lfind
#
# !INTERFACE
proc lfind args {

# !DESCRIPTION:
#    Routine to select all elements of an row  found with a lsearch-command
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC
	set l [ eval lsearch $args ]
	set n [ llength $l ]
	if { $n > 0 } {
	  set list [ lindex $args [ expr [ llength $args ] -2 ]]
	  if { $n > 1 } {
		foreach item $l {
		  lappend r [ lindex $list $item ]
		}
		return $r
	  } else {
 		return [ lindex $list $l ]
	  }
	}
	return
}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: Section
#
# !INTERFACE

proc Section { mode { text "" } } {

# !USES:
#
global VARS

# !INPUT PARAMETERS:
#
# !DESCRIPTION:
#    Set indetation for output
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

  switch -- $mode {
    -reset { set VARS(section) "" }
    -incr { lappend VARS(section) $text }
    -decr {
   	    set ret [ lindex $VARS(section) end ]
	    set VARS(section) [ lreplace $VARS(section) end end ]
	    return $ret
	  }
     -nr  {
	    return [ llength $VARS(section) ]
	  }
  }
}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE:
#
# !INTERFACE:
proc PrintSetup { mode { file "" } } {

# !USES:
#
global VARS

# !INPUT PARAMETERS:
#
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

  switch -- $mode {
	-openfile {
	   set VARS(nonewline) 0
	   set VARS(file) [ open $file w ]
	   return
	}
	-closefile {
	   close $VARS(file)
	   set VARS(file) stdout
	   return
	}
	-errorclose {
	   close $VARS(file)
	   set VARS(file) stdout
	   file delete $file
	   return
	}
	-stdout {
	   set VARS(nonewline) 0
	   Section -reset
	   set VARS(file) stdout
	   return
	 }
  }
}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE PrintLine
#
# !INTERFACE:
proc PrintLine { mode args } {

# !USES:
#
global VARS

# !INPUT PARAMETERS:
#
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

  set k "puts $VARS(file)"
  set blank ""


  if { $mode == "-block" || $VARS(nonewline)==1 } {
    set ll [ join $args ]
    set lbl 0
  } else {
    set lbl [ expr [ Section -nr ] +1 ]
    if { $mode == "-ninsert" } { incr lbl 2 }
    set blank [ string repeat " " $lbl ]
    set ll [ string trim [ join $args ] ]
  }

  switch -- $mode {
	-block { set k "puts -nonewline $VARS(file)" }
	-print {}
  	-crepeat {
		  set i [ expr ( 79 - [ string length $blank ] ) / \
					[ string length $ll ] ]
 	          set ll "\![string repeat $ll $i]"
		}
	-nonewline { set k "puts -nonewline $VARS(file)" }
	default { set k "puts -nonewline $VARS(file)" }
  }

  if { ![ regexp -- {-block|-nobreak} $mode ] } {
    set cont &
    set l [ expr 80 - 2*$lbl ]
    set comm ""
    # first character is the start character of comment line..
    if { $mode == "-cprint" } { regexp ^. $ll comm;append comm " " }
    set chr " "
    if { [regexp \; $ll ] && [ set i [ string length $ll ] ] > $l } {
      set ll [ split $ll \; ]; set chr "\;"
    }
    while { [ set i [ string length $ll ] ] > $l && \
       					[ set j [ llength $ll ] ] >= 2 } {
      set mm [ join [ lrange $ll 0 [ set m [ expr int( $l.0 /$i * $j -1) ] ] ] $chr ]
      while { [ set i [ string length $mm ] ] > $l && \
       					[ set j [ llength $mm ] ] > 2 } {
	 set mm [ join [ lrange $mm 0 [ set m [ expr int( $l.0 /$i * $j -1) ] ] ] $chr ]
      }
      if { $chr=="\;" } { eval $k [ list $blank$mm ] } { eval $k [ list $blank$mm$cont ] }
      if { ![ regexp -- {-print|-num} $mode ] } { puts $VARS(file) "" }
      set ll $comm[string trim [ join [ lrange $ll [incr m ] end ] ] ]	
      if { $mode != "-cprint" && $chr == " " } {
	set blank [ string repeat " " [ expr $lbl +1 ] ]
      }
    }

  }
  set VARS(nonewline) 0
  if { $ll != "" } {
     if { [regexp nonewline $k ] && ![ regexp {\n$} $ll ] } {
	set VARS(nonewline) 1
     }
     if { $mode == "-num" } {
	 set i [ string length [ set tmp [ lindex $ll 0 ] ] ]
	 set tmp [ string replace $blank 0 $i " $tmp" ]
	 eval $k [ list $tmp[lrange $ll 1 end ] ]
     } else {
	eval $k [ list $blank$ll ]
     }
  } else {
	eval $k [ list {} ]
  }

}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: foall options
#
proc foralloptions { uoption uvalues list script } {

# !INTERFACE:
#
upvar $uoption option $uvalues values

# !INPUT PARAMETERS:
#
# !OUTPUT PARAMETERS:
#
# !DESCRIPTION:
#	 Clever script to read in easely parameters to a tcl-function
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

  foreach item [ eval splitargs $list ] {
	set option [ lindex $item 0 ]
	set values [ join [ lrange $item 1 end ] ]
	uplevel $script
  }
}
#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: splitargs
#
proc splitargs args {

#
# !DESCRIPTION:
#	     See previous routine~
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC

  if { $args == "" } return
  foreach item $args {
	if { ![ regsub ^- $item "|-" t ] } { set t $item }
	lappend tmp $t
   }
  return [ lrange [ split $tmp | ] 1 end ]
}


#EOC
#-------------------------------------------------------------------------
#BOP
#
# !ROUTINE: searchforgroup
#
# !INTERFACE

proc searchforgroup { dim grpname } {

# !USES
global VARS
#
# !DESCRIPTION:
#	     See previous routine~
# !REVISION HISTORY:
#
#EOP
#-------------------------------------------------------------------------
#BOC
   set index [ lsearch $VARS($dim,group) $grpname ]
   if { $index < 0 } {
      set dx "2d"; if { $dim == "2d"} { set dx "3d" }
      set index [ lsearch $VARS($dx,group) $grpname ]
   } else {
     set dx $dim
   }
   set l [ lindex $VARS($dx,member) $index ]

  return $l
}

proc eval_selec { mode string } {

set k "*+a-zA-Z0-9_. "
set l [ format "\[%s\]+-\>\[%s\]+|\[%s\]+\<-\[%s\]+" $k $k $k $k ]
switch -- $mode {
   -check {
      if { [ set i [regexp -all $l $string ] ] >=2 } {
	  regsub -all $l $string "" tmp
	  set j [ regsub -all {\(\)} $tmp "" tmp ]
	  if { $j > $i } {
	    puts stdout "Error: too many brackets in: $string"
	    return 101
	  } elseif { $j < $i } {
	    puts stdout "Error: ther are no brackets around each flux statement "
	    puts stdout "or brackets within flux statement: $string"
	    return 101
	  } elseif { [ regexp {\(|\)} $tmp ] } {
	    puts stdout "Error: brackets on unexpected places in flux statement '$string'"
	  } elseif { [ expr $i - [ regexp -all {[-+]} $tmp ] ] != 1 } {
	     puts stdout " error in sum: between flux statements no - or + sign"
	     puts stdout "in flux statement $string"
	     return 102
	  } else {
	     regexp {[+a-zA-Z0-9_.]+} $string tmp
	     regsub {\+} $tmp \\+ tmp
	     if { [ regexp -all "${tmp} *->|${tmp} *<-" $string ] != $i } {
	       puts stdout "error: left hand of fluxes does not same variable name"
	       return 104
	     }
	  }
      } elseif { [ regexp {\<-+ *\(|-\>+ *\(} $string ] } {
	  puts stdout "Error with brackets: within a flux stament no brackets"
	  puts stdout "are allowed! In flux statement: $string"
	  return 106
      }
      return 0
   }
    -eval {
       set t +
       set i 0
       set status 1
       while { $status > 0 } {
	 if { $status==1 } {
	    set j [ regexp -indices -start $i $l $string r ]
	    set status 0
	    if { $j } {
	      set status 2
	      set tmp [ eval string range [ list $string ] $r ]
	      regexp -- {->|<-} $tmp ss
	      regsub -- $ss $tmp " " tmp
	      set cstate [ lindex $tmp 0 ]
	      set ss [ lindex {sink source} [ lsearch {-> <-} $ss ] ]
	      if { ![ info exist coll ] } { lappend coll $cstate }
	      set coll2 [ list $t $ss ]
	      set ostates [ split [ lindex $tmp 1 ] + ]
	      eval lappend coll2 $ostates
	      lappend coll $coll2
	      set i [ lindex $r 1 ]
	    }
	  } else {
	    set j [ regexp -indices -start $i {[-+]} $string r ]
	    set status 0
	    if { $j } {
	       set status 1
	       set t [ eval string range [ list $string ] $r ]
	       set i [ lindex $r 1 ]
	    }
	  }
       }
       return $coll
   }
}
return

}

proc expand_selec_fluxes { dim string } {
global VARS


#test on sum: if so split lines:
set coll [ list $string ]
foreach item $coll {
    if { [ set i [ lsearch -regexp $item {[^ ]+ [^ ]+ [^ ]+ [^ ]+} ] ] >0 } {
      set fluxdesc [ lindex $item $i ]
      set statesrow [ lrange $fluxdesc 2 end ]
      set rest [ lreplace $item $i $i ]
      foreach jtem $statesrow {
	set tmp [ lreplace $fluxdesc 2 end $jtem ]
	lappend rest $tmp
      }
      lappend coll2 $rest
    }
}
if { [ info exists coll2 ] } {
  set coll $coll2
  unset coll2
}

# check on pattern and split lines:
set j 1
while { $j } {
  foreach jtem $coll {
    set item [ lrange $jtem 1 end ]
    if { [set i [ lsearch -regexp $item {[.]} ] ] >=0 } {
	set fluxdesc [ lindex $item $i ]
	set state [ lindex $fluxdesc 2 ]
	incr i
	set rest [ lreplace $jtem $i $i ]
	set l [ lsearch -all -inline -regexp $VARS($dim,state,name) $state ]
	if { [ llength $l ]==0 } {
	  puts stdout "State var $state does not exist"
	  return 105
	}
	foreach ktem $l {
	  set tmp [ lreplace $fluxdesc 2 2 $ktem ]
	  lappend rest $tmp
	}
	lappend coll2 $rest
    } else {
      set j 0
    }
  }
  if { [ info exists coll2 ] } {
    set coll $coll2
    unset coll2
  }
}

set states [ lindex $string 0 ]
if { [ regexp {[+]} $states ] } { set states [ split $states + ] }
foreach jtem $states {
  set l [ lsearch -all -inline -regexp $VARS($dim,state,name) $jtem ]
  if { [ llength $l ] == 0 } {
    puts stdout "Error: State var $state does not exist"
    return 105
  }
  # add line for each state var and replace * with state varname
  foreach ktem $l {
    foreach item $coll {
      set tmp [ lreplace $item 0 0 $ktem ]
      regsub -all -- {[*]} $tmp $ktem tmp
      lappend coll2 $tmp
    }
  }
}
if { [ info exists coll2 ] } {
  set coll $coll2
  unset coll2
}

#reorganize:
unset states
foreach item $coll {
  set state [ lindex $item 0 ]
  foreach jtem [ lrange $item 1 end ] {
    lappend states $state
    lappend t [ lindex $jtem 0 ]
    lappend ss [ lindex $jtem 1 ]
    lappend ostates [ lindex $jtem 2 ]
  }
}
  return [ list $t $ss $states $ostates ]

}


#-------------------------------------------------------------------------
#    Copyright Piet Ruardij, NIOZ,NL (rua@nioz.nl) and BFM-team   2006
#-------------------------------------------------------------------------


exit [ eval make_f90 $argv ]

